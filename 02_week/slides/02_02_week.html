<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Coding Assignment: Mapping Data to Visual Encodings</title>
    <meta charset="utf-8" />
    <meta name="author" content="Jared Edgerton" />
    <script src="02_02_week_files/header-attrs-2.29/header-attrs.js"></script>
    <link href="02_02_week_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="02_02_week_files/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="02_02_week_files/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="plsc498.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Coding Assignment: Mapping Data to Visual Encodings
]
.subtitle[
## Reproducible workflow + plots + short write-up
]
.author[
### Jared Edgerton
]

---


# What You Are Building

You will complete a small, end-to-end workflow:

- Set up a reproducible project structure
- Load a dataset
- Inspect variables and types
- Produce plots that illustrate different encodings
- Save plots to files
- Generate a short write-up template
- Commit + push your work

---

# Rules for This Assignment

- Run code **top-to-bottom** inside an R Project
- No user-defined functions
- No copy/paste screenshots
- Save outputs to:
  - `figures/`
  - `outputs/`

---

# 0) Setup: packages + reproducibility


``` r
# Install packages if needed (run once; then comment out)
# install.packages("ggplot2")
# install.packages("dplyr")

library(ggplot2)
library(dplyr)

set.seed(123)
```

---

# 1) Create project folders


``` r
dir.create("data_raw", showWarnings = FALSE)
dir.create("data_processed", showWarnings = FALSE)
dir.create("scripts", showWarnings = FALSE)
dir.create("outputs", showWarnings = FALSE)
dir.create("figures", showWarnings = FALSE)
```

---

# 2) Load a dataset (built-in)

We use a built-in dataset so nothing can break.


``` r
dat &lt;- ggplot2::mpg
```

---

# 3) Quick inspection

Keep this short and purposeful:
- What columns exist?
- What types/ranges matter for the plot?


``` r
print(head(dat))
```

```
## # A tibble: 6 × 11
##   manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class 
##   &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 
## 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa…
## 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa…
## 3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa…
## 4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa…
## 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa…
## 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa…
```

``` r
print(summary(dat[, c("displ", "hwy", "class")]))
```

```
##      displ            hwy           class          
##  Min.   :1.600   Min.   :12.00   Length:234        
##  1st Qu.:2.400   1st Qu.:18.00   Class :character  
##  Median :3.300   Median :24.00   Mode  :character  
##  Mean   :3.472   Mean   :23.44                     
##  3rd Qu.:4.600   3rd Qu.:27.00                     
##  Max.   :7.000   Max.   :44.00
```

---

# 4A) Plot A: baseline scatter (position encodes two quantitative variables)


``` r
p1 &lt;- ggplot(dat, aes(x = displ, y = hwy)) +
  geom_point() +
  theme_gray()
print(p1)
```

![](02_02_week_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;

``` r
ggsave(
  filename = "figures/plot_A_baseline_scatter.png",
  plot = p1,
  width = 6, height = 4, dpi = 300
)
```

---

# 4B) Plot B: map a categorical variable to color


``` r
p2 &lt;- ggplot(dat, aes(x = displ, y = hwy, color = class)) +
  geom_point() +
  theme_gray()
print(p2)
```

![](02_02_week_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;

``` r
ggsave(
  filename = "figures/plot_B_color_by_class.png",
  plot = p2,
  width = 7, height = 4.5, dpi = 300
)
```

---

# 4C) Plot C: styling vs mapping (constant color is NOT encoding data)


``` r
p3 &lt;- ggplot(dat, aes(x = displ, y = hwy)) +
  geom_point(color = "blue") +
  theme_gray()
print(p3)
```

![](02_02_week_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;

``` r
ggsave(
  filename = "figures/plot_C_styling_constant_color.png",
  plot = p3,
  width = 6, height = 4, dpi = 300
)
```

---

class: small-code

# 5) Create the write-up template

Students will answer prompts in a short markdown file.


``` r
writeup_lines &lt;- c(
  "Create an R Project for the class in your synced drive.",
  "",
   "# Find the new data set for the in-class assignment.",
  "",
  "# Short Write-Up: Mapping Data to Visual Encodings",
  "",
  "For each plot:",
  "",
  "1) What question is this plot helping answer?",
  "2) What variables are mapped to what visual properties?",
  "3) What comparison is easiest to make? What is harder?",
  "4) Identify one design choice that is a *default* and explain whether it helps or hurts.",
  "",
  "## Optional stretch",
  "- Create a second version of ONE plot optimized for a different audience (e.g., general public vs technical).",
  "- Explain what you changed and why."
)

writeLines(writeup_lines, con = "outputs/writeup_mapping_encodings.md")
```

---

# Submission checklist

You should have:

- `figures/plot_1_baseline_scatter.png`
- `figures/plot_2_color_and_or_size.png`
- `figures/plot_3_color_and_or_size.png`
- `outputs/writeup_mapping_encodings.md`

---

# Git workflow reminder (Terminal, not Console)

Run these in the **Terminal tab**:

```bash
git status
git add .
git commit -m "Mapping encodings assignment"
git push
```

---

# What success looks like

Success means:
- Your code runs top-to-bottom
- The PNGs are saved in `figures/`
- The write-up file exists in `outputs/`
- Your repo has at least one commit pushed to GitHub
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightStyle": "github",
  "highlightLines": true,
  "countIncrementalSlides": false,
  "slideNumberFormat": ""
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
