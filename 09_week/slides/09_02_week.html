<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Coding Assignment: Proportions and Nested Proportions</title>
    <meta charset="utf-8" />
    <meta name="author" content="Jared Edgerton" />
    <script src="09_02_week_files/header-attrs-2.29/header-attrs.js"></script>
    <link href="09_02_week_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="09_02_week_files/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="09_02_week_files/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="plsc498.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Coding Assignment: Proportions and Nested Proportions
]
.subtitle[
## A quick recap + starter patterns you will extend (stacked, normalized, nested)
]
.author[
### Jared Edgerton
]

---



# Today (quick recap → code you will extend)

We are practicing **composition** questions:

- Always identify the **denominator** (“proportion *of what*?”)
- Stacked vs side-by-side bars are for **different comparisons**
- Normalized stacked bars (`position = "fill"`) show **within-x proportions**
- Nested proportions = **parts within parts** (often easiest with facets)

Goal: reuse these patterns for **state-level social data**:
- election outcome group (e.g., winner group)
- COVID and pneumonia deaths (pre-election window)

---

# Setup


``` r
library(tidyverse)
library(ggplot2)
library(scales)
library(forcats)

set.seed(123)
```

---

# Simulated data



``` r
st_name &lt;- c(state.name, "District of Columbia"); st_abbr &lt;- c(state.abb, "DC"); st_region &lt;- c(as.character(state.region), "South")
n_states &lt;- length(st_name)
votes_total &lt;- round(rlnorm(n_states, meanlog = log(3.1e6), sdlog = 0.9))
share_blue_raw &lt;- rbeta(n_states, shape1 = 40, shape2 = 40)
share_blue &lt;- share_blue_raw +   ifelse(st_region == "Northeast",  0.03, 0) +
  ifelse(st_region == "South",     -0.02, 0) +  ifelse(st_region == "West",       0.01, 0)
share_blue &lt;- pmin(pmax(share_blue, 0.05), 0.95)
votes_blue &lt;- round(votes_total * share_blue); votes_red  &lt;- votes_total - votes_blue
share_blue &lt;- votes_blue / votes_total; share_red  &lt;- votes_red  / votes_total
margin_blue &lt;- share_blue - share_red
winner_group &lt;- ifelse(margin_blue &gt;= 0, "Blue winner", "Red winner"); winner_group &lt;- factor(winner_group, levels = c("Blue winner", "Red winner"))
deaths_covid_pre &lt;- round(rlnorm(n_states, meanlog = log(9000), sdlog = 0.8))
deaths_pneum_pre &lt;- round(rlnorm(n_states, meanlog = log(12000), sdlog = 0.8))
deaths_covid_pre &lt;- round(deaths_covid_pre * (votes_total / mean(votes_total))^0.20)
deaths_pneum_pre &lt;- round(deaths_pneum_pre * (votes_total / mean(votes_total))^0.20)
state_synth &lt;- tibble(
  st_name = st_name, st_abbr = st_abbr,
  region = factor(st_region, levels = c("Northeast", "Midwest", "South", "West")),
  votes_total = votes_total, votes_blue = votes_blue, votes_red = votes_red,
  share_blue = share_blue, share_red = share_red,
  margin_blue = margin_blue,
  deaths_covid_pre = deaths_covid_pre, deaths_pneum_pre = deaths_pneum_pre,
  winner_group = winner_group)
```

---

# Quick check: ranges look reasonable?


``` r
state_synth %&gt;% summarise(n_states = n(),
    votes_total_min = min(votes_total), votes_total_median = median(votes_total),
    votes_total_max = max(votes_total), share_blue_min = min(share_blue),
    share_blue_median = median(share_blue), share_blue_max = max(share_blue),
    covid_min = min(deaths_covid_pre), covid_median = median(deaths_covid_pre),
    covid_max = max(deaths_covid_pre), pneum_min = min(deaths_pneum_pre),
    pneum_median = median(deaths_pneum_pre), pneum_max = max(deaths_pneum_pre))
```

```
## # A tibble: 1 × 13
##   n_states votes_total_min votes_total_median votes_total_max share_blue_min
##      &lt;int&gt;           &lt;dbl&gt;              &lt;dbl&gt;           &lt;dbl&gt;          &lt;dbl&gt;
## 1       51          528056            2931991        21833871          0.399
## # ℹ 8 more variables: share_blue_median &lt;dbl&gt;, share_blue_max &lt;dbl&gt;,
## #   covid_min &lt;dbl&gt;, covid_median &lt;dbl&gt;, covid_max &lt;dbl&gt;, pneum_min &lt;dbl&gt;,
## #   pneum_median &lt;dbl&gt;, pneum_max &lt;dbl&gt;
```

---

# Variable mapping (synthetic → real)

When you swap in the real dataset, you’ll map:

- `winner_group` → (winner based on vote shares / margin)
- `deaths_covid_pre` → (COVID deaths up to the cutoff date)
- `deaths_pneum_pre` → (pneumonia deaths up to the cutoff date)
- `region` → (optional grouping variable for nested proportions)

The **plot patterns** are the point: keep the structure, swap the column names.

---

# Starter pattern: counts (how many states in each winner group?)

Counts answer: “How many states are in each group?”


``` r
ggplot(state_synth, aes(x = winner_group)) +
  geom_bar() +
  theme_classic() +
  labs(x = NULL, y = "Number of states")
```

![](09_02_week_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---

# Same data, different question

Proportions answer: “What fraction of states are in each group?”


``` r
ggplot(state_synth, aes(x = 1, fill = winner_group)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = percent_format()) +
  theme_classic() +
  labs(x = NULL, y = "Proportion of states", fill = NULL)
```

![](09_02_week_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;

---

# Nested proportions: within each region, what share of states are Blue/Red?

Here the denominator is: **within each region**.


``` r
ggplot(state_synth, aes(x = region, fill = winner_group)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = percent_format()) +
  theme_classic() +
  labs(x = NULL, y = "Proportion (within region)", fill = NULL)
```

![](09_02_week_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;

Interpretation prompts:
- Which regions are more “Blue winner” vs “Red winner” in this synthetic data?
- What comparison is easiest in a normalized stacked bar? (top/bottom segments)

---

# Side-by-side alternative (different comparison)

If you want to compare **counts** (not proportions), use side-by-side.


``` r
ggplot(state_synth, aes(x = region, fill = winner_group)) +
  geom_bar(position = "dodge") +
  theme_classic() +
  labs(x = NULL, y = "Number of states", fill = NULL)
```

![](09_02_week_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;

---

# Composition outcome: where do deaths come from?

Now the “whole” is **total deaths** (across states), split by winner group.

First, put the two death variables into long format.


``` r
deaths_long &lt;- state_synth %&gt;%
  select(st_name, region, winner_group, deaths_covid_pre, deaths_pneum_pre) %&gt;%
  pivot_longer(
    cols = c(deaths_covid_pre, deaths_pneum_pre),
    names_to = "death_type",
    values_to = "deaths"
  ) %&gt;%
  mutate(
    death_type = recode(death_type,
                        deaths_covid_pre = "COVID deaths (pre-election)",
                        deaths_pneum_pre = "Pneumonia deaths (pre-election)")
  )
```

---

# Total deaths by type (counts)

Counts answer: “How many total deaths are we talking about?”


``` r
deaths_long %&gt;%
  group_by(death_type, winner_group) %&gt;%
  summarise(total_deaths = sum(deaths), .groups = "drop") %&gt;%
  ggplot(aes(x = death_type, y = total_deaths, fill = winner_group)) +
  geom_col() +
  scale_y_continuous(labels = comma_format()) +
  theme_classic() +
  labs(x = NULL, y = "Total deaths", fill = NULL)
```

![](09_02_week_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

---

# Same data, different question

Proportions answer: “Within COVID (or pneumonia), what share of deaths come from Blue-winner vs Red-winner states?”


``` r
deaths_long %&gt;% group_by(death_type, winner_group) %&gt;%
  summarise(total_deaths = sum(deaths), .groups = "drop") %&gt;%
  ggplot(aes(x = death_type, y = total_deaths, fill = winner_group)) +
  geom_col(position = "fill") +
  scale_y_continuous(labels = percent_format()) +
  theme_classic() +
  labs(x = NULL, y = "Proportion of deaths (within type)", fill = NULL)
```

![](09_02_week_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;

---

# Nested proportions

Now the denominator is: **within each region AND death type**.


``` r
deaths_long %&gt;% group_by(region, death_type, winner_group) %&gt;%
  summarise(total_deaths = sum(deaths), .groups = "drop") %&gt;%
  ggplot(aes(x = region, y = total_deaths, fill = winner_group)) +
  geom_col(position = "fill") +
  facet_wrap(~ death_type) +
  scale_y_continuous(labels = percent_format()) +
  theme_classic() +
  labs(x = NULL, y = "Proportion (within region)", fill = NULL)
```

![](09_02_week_files/figure-html/unnamed-chunk-11-1.png)&lt;!-- --&gt;

---

# Small multiples

Stacking can make some comparisons hard (middle segments). A common repair: **one panel per group** with a common y-axis.


``` r
deaths_long %&gt;% group_by(region, death_type, winner_group) %&gt;% 
  summarise(total_deaths = sum(deaths), .groups = "drop") %&gt;%
  ggplot(aes(x = region, y = total_deaths)) +
  geom_col() +
  facet_grid(winner_group ~ death_type) +
  scale_y_continuous(labels = comma_format()) +
  theme_classic() +
  labs(x = NULL, y = "Total deaths")
```

![](09_02_week_files/figure-html/unnamed-chunk-12-1.png)&lt;!-- --&gt;

---

# Waffle plot for composition

A waffle plot is a **parts-to-whole** display. It can work when there are few categories.

Here we show: the share of total COVID deaths coming from each winner group.


``` r
covid_props &lt;- deaths_long %&gt;%
  filter(death_type == "COVID deaths (pre-election)") %&gt;%
  group_by(winner_group) %&gt;%
  summarise(total = sum(deaths), .groups = "drop") %&gt;%
  mutate(prop = total / sum(total)) %&gt;%
  arrange(desc(prop)) %&gt;%
  mutate(pct = floor(prop * 100))

remainder &lt;- 100 - sum(covid_props$pct)
covid_props$pct[1] &lt;- covid_props$pct[1] + remainder

waffle_df &lt;- covid_props %&gt;%
  select(winner_group, pct) %&gt;%
  tidyr::uncount(weights = pct) %&gt;%
  mutate(
    square = dplyr::row_number(),
    row = (square - 1) %/% 10 + 1,
    col = (square - 1) %% 10 + 1
  )
```

---

# Waffle plot


``` r
ggplot(waffle_df, aes(x = col, y = row, fill = winner_group)) +
  geom_tile(color = "white", linewidth = 0.4) +
  coord_equal() +
  scale_y_reverse() +
  scale_fill_brewer(palette = "Dark2") +
  theme_void() +
  theme(legend.position = "bottom") +
  labs(title = "COVID deaths composition (waffle plot)", fill = NULL)
```

![](09_02_week_files/figure-html/unnamed-chunk-14-1.png)&lt;!-- --&gt;

---

# Design justification 

For any composition plot you make, you should be able to write:

- What is the **whole**?
- What are the **parts**?
- What comparisons does this design make easy?
- What comparisons does it make hard?
- What alternative would you choose for a different question?

---

# Save a figure


``` r
p &lt;- deaths_long %&gt;%
  group_by(death_type, winner_group) %&gt;%
  summarise(total_deaths = sum(deaths), .groups = "drop") %&gt;%
  ggplot(aes(x = death_type, y = total_deaths, fill = winner_group)) +
  geom_col(position = "fill") +
  scale_y_continuous(labels = percent_format()) +
  theme_classic() +
  labs(x = NULL, y = "Proportion of deaths (within type)", fill = NULL)

ggsave(filename = "deaths_composition_normalized.png", plot = p, width = 8, height = 4, dpi = 300)
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightStyle": "github",
  "highlightLines": true,
  "countIncrementalSlides": false,
  "slideNumberFormat": ""
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
