<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Proportions and Nested Proportions</title>
    <meta charset="utf-8" />
    <meta name="author" content="Jared Edgerton" />
    <script src="09_01_week_files/header-attrs-2.29/header-attrs.js"></script>
    <link href="09_01_week_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="09_01_week_files/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="09_01_week_files/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="plsc498.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Proportions and Nested Proportions
]
.subtitle[
## Parts-to-whole arguments and conditional composition
]
.author[
### Jared Edgerton
]

---


class: center, middle, inverse, title-slide

.title[
# Proportions and Nested Proportions
]
.subtitle[
## Parts-to-whole arguments and conditional composition
]
.author[
### Jared Edgerton
]

---

# Quiz on canvas

- Log on to the course website to take it.
- You have 10 minutes.
- It is open notes and web.
- Do not generate your answers with AI.

---

# Quick Recap

- Last time, we focused on:
  - ECDFs (fewer tuning knobs)
  - Q–Q plots (diagnosing departures from normal)
  - many distributions at once (box/violin/points)
  - multipanel figures (facets)

Today, we focus on **composition**:

- parts-to-whole reasoning (what is the denominator?)
- stacked vs side-by-side comparisons
- when (and when not) to use pies
- nested proportions (parts within parts)

---

# Simulated data for today


``` r
library(ggplot2); library(dplyr); library(tidyr); library(forcats); library(scales)
set.seed(123)
n &lt;- 2500
df &lt;- tibble(
  id = 1:n,
  party = sample(c("Democrat", "Independent", "Republican"), size = n, replace = TRUE, prob = c(0.43, 0.17, 0.40)),
  education = sample(c("HS or less", "Some college", "BA", "Graduate"), size = n, replace = TRUE, prob = c(0.33, 0.30, 0.22, 0.15)),
  region = sample(c("Northeast", "Midwest", "South", "West"), size = n, replace = TRUE, prob = c(0.18, 0.21, 0.40, 0.21)),
  wave = sample(paste0("Wave ", 1:4), size = n, replace = TRUE))
df &lt;- df %&gt;%
  mutate(
    educ_num = as.numeric(factor(education, levels = c("HS or less", "Some college", "BA", "Graduate"))),
    wave_num = as.numeric(factor(wave, levels = paste0("Wave ", 1:4))),
    base_support = case_when(party == "Democrat" ~ 0.62, party == "Independent" ~ 0.50, party == "Republican" ~ 0.38),
    p_support = pmin(pmax(base_support + (educ_num - 2.5) * 0.04 + (wave_num - 2.5) * 0.02 + rnorm(n, 0, 0.03), 0.05), 0.90),
    p_neutral = 0.18,
    p_oppose = 1 - p_support - p_neutral,
    u = runif(n),
    attitude = case_when(u &lt; p_support ~ "Support", u &lt; p_support + p_neutral ~ "Neutral", TRUE ~ "Oppose"),
    college = if_else(education %in% c("BA", "Graduate"), "College", "No college")
  ) %&gt;%
  dplyr::select(-educ_num, -wave_num, -base_support, -p_support, -p_neutral, -p_oppose, -u)
```

---

# Inspect data


``` r
df %&gt;% 
  slice(1:10)
```

```
## # A tibble: 10 × 7
##       id party       education    region    wave   attitude college   
##    &lt;int&gt; &lt;chr&gt;       &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;     
##  1     1 Democrat    Graduate     South     Wave 4 Support  College   
##  2     2 Republican  BA           Northeast Wave 3 Support  College   
##  3     3 Democrat    BA           West      Wave 1 Oppose   College   
##  4     4 Independent HS or less   West      Wave 1 Oppose   No college
##  5     5 Independent BA           South     Wave 1 Support  College   
##  6     6 Democrat    Some college South     Wave 3 Support  No college
##  7     7 Republican  BA           South     Wave 3 Support  College   
##  8     8 Independent BA           Midwest   Wave 4 Neutral  College   
##  9     9 Republican  Graduate     West      Wave 4 Support  College   
## 10    10 Republican  Some college South     Wave 2 Oppose   No college
```

---

# Parts-to-whole reasoning

When you plot proportions, you are making a claim about a **denominator**.

Two questions to ask *before* you plot:

- What is the "whole"?
- Within which group(s) are we computing shares?

---

# Example: counts (party)


``` r
party_counts &lt;- df %&gt;%
  count(party) %&gt;%
  mutate(party = fct_infreq(party))
ggplot(party_counts, aes(x = party, y = n)) +
  geom_col() +
  theme_classic() +
  labs(x = NULL, y = "Count", title = "Party identification (counts)")
```

![](09_01_week_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---

# Example: proportions 

Same data. Different message.


``` r
party_props &lt;- df %&gt;%
  count(party) %&gt;%
  mutate(prop = n / sum(n), party = fct_infreq(party))
ggplot(party_props, aes(x = party, y = prop)) +
  geom_col() +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  theme_classic() +
  labs(x = NULL, y = "Share of respondents", title = "Party identification (proportions)", subtitle = "The denominator is: everyone in the dataset")
```

![](09_01_week_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---

# Example: a pie chart (simple fractions)

Pie charts can work when: (a) there are few categories and (b) the story is about *simple fractions*. They are weak when you need precise comparisons.


``` r
ggplot(party_props, aes(x = "", y = prop, fill = party)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  theme_classic() +
  theme(axis.title = element_blank(), axis.text = element_blank(), axis.ticks = element_blank()) +
  labs(title = "Party composition (pie chart)")
```

![](09_01_week_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;

---


# Example: a waffle plot (100 units)

Waffle plots can be a nice alternative to pies when:

- you want a *parts-to-whole* view
- you want the comparison to happen by **counting units** (not angles)

Here: **one square = 1 percentage point**.

We use `theme_void()` because axis ticks carry no information for a waffle grid.

---

# Code waffle plot

```r
waffle_party &lt;- party_props %&gt;%
  mutate(party = fct_infreq(party)) %&gt;%
  arrange(party) %&gt;%
  mutate(pct = floor(prop * 100))
remainder &lt;- 100 - sum(waffle_party$pct)
waffle_party$pct[1] &lt;- waffle_party$pct[1] + remainder
waffle_df &lt;- waffle_party %&gt;%
  select(party, pct) %&gt;%
  tidyr::uncount(weights = pct) %&gt;%
  mutate(
    square = dplyr::row_number(),          # &lt;-- global index across all tiles
    row = (square - 1) %/% 10 + 1,
    col = (square - 1) %% 10 + 1
  )
ggplot(waffle_df, aes(x = col, y = row, fill = party)) +
  geom_tile(color = "white", linewidth = 0.4) +
  coord_equal() +
  scale_y_reverse() +
  scale_fill_brewer(palette = "Set2") +
  theme_void() +
  theme(legend.position = "bottom") +
  labs(title = "Party composition (waffle plot)")
```

---


# Waffle plot

![](09_01_week_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;

---

# Example: higher-contrast waffle colors

`Dark2` is a higher-contrast palette than `Set2`. Use it when: (a) you have fewer categories and (b) you need the groups to separate clearly


``` r
ggplot(waffle_df, aes(x = col, y = row, fill = party)) +
  geom_tile(color = "white", linewidth = 0.4) +
  coord_equal() +
  scale_y_reverse() +
  scale_fill_brewer(palette = "Dark2") +
  theme_void() +
  theme(legend.position = "bottom") +
  labs(title = "Party composition (waffle plot, Dark2 palette)")
```

![](09_01_week_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;

---

# Pause and discuss with a neighbor

You have three views of the same composition:

1) a bar chart
2) a pie chart
3) a waffle plot

**Prompt:**

- Which makes comparison easiest?
- What does the pie chart encourage you to notice?
- What does it make hard to compare?

---


# Data visualization critique

- Take five minutes
  - What relationship is the figure claiming?
  - Is the main comparison happening by **position** or by something less accurate?
  - Does the design help you assess *strength* vs *noise*?
  - What is one concrete improvement?

.center[
&lt;img src="internet_speed_cost.png" style="width:50%;"&gt;
]


---


# Example: stacked bars

Here, the *whole* depends on what you want: (a) counts: total respondents in each region and (b) proportions: share within each region


``` r
ggplot(df, aes(x = region, fill = party)) +
  geom_bar() +
  theme_classic() +
  labs(x = NULL, y = "Count", title = "Party by region (stacked counts)")
```

![](09_01_week_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;

---

# Example: normalized stacks

`position = "fill"` changes the y-axis into a **within-x share**.


``` r
ggplot(df, aes(x = region, fill = party)) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  theme_classic() +
  labs(x = NULL, y = "Share within region", title = "Party by region (normalized stacked bars)", subtitle = "Now the denominator is: respondents within each region")
```

![](09_01_week_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

---


# Data visualization critique

- Take five minutes
  - What relationship is the figure claiming?
  - Is the main comparison happening by **position** or by something less accurate?
  - Does the design help you assess *strength* vs *noise*?
  - What is one concrete improvement?

.center[
&lt;img src="pie_chart.png" style="width:65%;"&gt;
]

---

# Example: nested proportions

Now the denominator changes *again*. Within each party, how does the attitude breakdown differ by education?


``` r
df_nested &lt;- df %&gt;%
  mutate(education = factor(education, levels = c("HS or less", "Some college", "BA", "Graduate"), labels = c("HS/\nless", "Some\ncollege", "BA", "Graduate")),
         party = factor(party, levels = c("Democrat", "Independent", "Republican")))
ggplot(df_nested, aes(x = education, fill = attitude)) +
  geom_bar(position = "fill") +
  facet_wrap(~ party, nrow = 1) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  theme_classic() +
  labs(x = NULL, y = "Share within education (within party)", title = "Nested proportions via small multiples", subtitle = "Each bar sums to 100% within a party panel")
```

![](09_01_week_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;

---

# Data visualization critique 

- Take five minutes
  - What is the plot comparing: **shape** or **totals**?
  - Do the design choices make comparisons easy?
  - What would change if you used an ECDF instead?
  - After doing this, talk to your neighbor briefly and compare notes.

.center[
&lt;img src="time_spent.png" style="width:65%;"&gt;
]


---

# What success looks like

- You can state the denominator in words before you plot.
- You can choose between:
  - counts vs proportions
  - stacked vs side-by-side
  - one plot vs small multiples
- You can explain when a pie chart helps (rarely) and when it hurts.
- You can make nested proportions readable by conditioning (facets).

---


# In-Class Activity

Find a visualization online.

With a neighbor:
- Identify the data variables
- Identify the visual mappings
- Decide what message the plot is making
- Suggest one concrete improvement


---

# What Comes Next

Next, we will practice composition tasks with social data:

- stacked and normalized bars
- nested proportions with conditioning
- short written justifications (what comparison is made easy?)

Focus on clarity, not cleverness.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightStyle": "github",
  "highlightLines": true,
  "countIncrementalSlides": false,
  "slideNumberFormat": ""
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
